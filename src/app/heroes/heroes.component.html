<!--使用 UppercasePipe 进行格式化-->
<!--绑定表达式中的 uppercase 位于管道操作符（ | ）的右边，用来调用内置管道 UppercasePipe。-->
<!--管道 是格式化字符串、金额、日期和其它显示数据的好办法。 Angular 发布了一些内置管道，而且你还可以创建自己的管道。-->
<!--<h2>{{hero.name | uppercase}} Details</h2>-->
<!--<div><span>id: </span>{{hero.id}}</div>-->

<!--[(ngModel)] 是 Angular 的双向数据绑定语法。-->
<!--这里把 hero.name 属性绑定到了 HTML 的 textbox 元素上，以便数据流可以双向流动：从 hero.name 属性流动到 textbox，并且从 textbox 流回到 hero.name 。-->

<!--<label>name:-->
    <!--缺少 FormsModule 虽然 ngModel 是一个有效的 Angular 指令，不过它在默认情况下是不可用的。
        它属于一个可选模块 FormsModule，你必须自行添加此模块才能使用该指令。-->
<!--<input [(ngModel)]="hero.name" placeholder="name">-->
<!--</label>-->
<h2>My Heroes</h2>
<ul class="heroes">
  <!--<li *ngFor="let hero of heroes"-->
  <!--[class.selected]="hero === selectedHero"-->
  <!--(click)="onSelect(hero)">-->
  <!--<span class="badge">{{hero.id}}</span> {{hero.name}}-->
  <!--</li>-->
  <li *ngFor="let hero of heroes">
    <a routerLink="/detail/{{hero.id}}">
      <span class="badge">{{hero.id}}</span> {{hero.name}}
    </a>
    <button class="delete" title="delete hero"
            (click)="delete(hero)">x
    </button>
  </li>
</ul>
<div>
  <label>Hero name:
    <input #addHeroName/>
  </label>
  <!-- (click) passes input value to add() and then clears the input -->
  <button (click)="add(addHeroName.value); addHeroName.value=''">
    add
  </button>
</div>


<!--把原来的 HeroesComponent 重构成两个组件带来了一些优点，无论是现在还是未来：-->
<!--你通过缩减 HeroesComponent 的职责简化了该组件。-->
<!--你可以把 HeroDetailComponent 改进成一个功能丰富的英雄编辑器，而不用改动父组件 HeroesComponent。-->
<!--你可以改进 HeroesComponent，而不用改动英雄详情视图。-->
<!--将来你可以在其它组件的模板中重复使用 HeroDetailComponent。-->
<!--[hero]="selectedHero" 是 Angular 的属性绑定语法。-->
<!--这是一种单向数据绑定。-->
<!--<app-hero-detail [hero]="selectedHero"></app-hero-detail>-->

<!------------------------------------------- 分割线------------------------------------------------------------------------>
<!--模板语法-->
<!--模板很像标准的 HTML，但是它还包含 Angular 的模板语法，这些模板语法可以根据你的应用逻辑、应用状态和 DOM 数据来修改这些 HTML。
你的模板可以使用数据绑定来协调应用和 DOM 中的数据，使用管道在显示出来之前对其进行转换，使用指令来把程序逻辑应用到要显示的内容上。-->
<!--这个模板使用了典型的 HTML 元素，比如 <h2> 和 <p>，还包括一些 Angular 的模板语法元素，
如 *ngFor，{{hero.name}}，click、[hero] 和 <app-hero-detail>。
这些模板语法元素告诉 Angular 该如何根据程序逻辑和数据在屏幕上渲染 HTML。-->

<!--数据绑定-->
<!--如果没有框架，你就要自己负责把数据值推送到 HTML 控件中，并把来自用户的响应转换成动作和对值的更新。
手动写这种数据推拉逻辑会很枯燥、容易出错，难以阅读 —— 用过 jQuery 的程序员一定深有体会。-->
<!--Angular 支持双向数据绑定，这是一种对模板中的各个部件与组件中的各个部件进行协调的机制。
往模板 HTML 中添加绑定标记可以告诉 Angular 该如何连接它们。-->
<!--数据绑定在模板及其组件之间的通讯中扮演了非常重要的角色，它对于父组件和子组件之间的通讯也同样重要。-->

<!--<li>{{hero.name}}</li>-->
<!--{{hero.name}}插值表达式在 <li> 标签中显示组件的 hero.name 属性的值。-->

<!--<app-hero-detail [hero]="selectedHero"></app-hero-detail>-->
<!--[hero]属性绑定把父组件 HeroListComponent 的 selectedHero 的值传到子组件 HeroDetailComponent 的 hero 属性中。-->

<!--<li (click)="selectHero(hero)"></li>-->
<!--当用户点击某个英雄的名字时，(click) 事件绑定会调用组件的 selectHero 方法。-->

<!--<input [(ngModel)]="hero.name">-->
<!--双向数据绑定（主要用于模板驱动表单中），它会把属性绑定和事件绑定组合成一种单独的写法。-->
<!--在双向绑定中，数据属性值通过属性绑定从组件流到输入框。用户的修改通过事件绑定流回组件，把属性值设置为最新的值。-->
<!--Angular 在每个 JavaScript 事件循环中处理所有的数据绑定，它会从组件树的根部开始，递归处理全部子组件。-->

<!--管道-->
<!--Angular 的管道可以让你在模板中声明显示值的转换逻辑。 带有 @Pipe 装饰器的类中会定义一个转换函数，用来把输入值转换成供视图显示用的输出值。-->
<!--Angular 自带了很多管道，比如 date 管道和 currency 管道，完整的列表参见 Pipes API 列表。你也可以自己定义一些新管道。-->
<!--要在 HTML 模板中指定值的转换方式，请使用 管道操作符 (|)。-->
<!--{{interpolated_value | pipe_name}}-->
<!--你可以把管道串联起来，把一个管道函数的输出送给另一个管道函数进行转换。 管道还能接收一些参数，来控制它该如何进行转换。
比如，你可以把要使用的日期格式传给 date 管道：-->
<!-- Default format: output 'Jun 15, 2015'-->
<!--<p>Today is {{today | date}}</p>-->
<!-- fullDate format: output 'Monday, June 15, 2015'-->
<!--<p>The date is {{today | date:'fullDate'}}</p>-->
<!-- shortTime format: output '9:43 AM'-->
<!--<p>The time is {{today | date:'shortTime'}}</p>-->

<!--指令 Directives-->
<!--Angular 的模板是动态的。当 Angular 渲染它们的时候，会根据指令给出的指示对 DOM 进行转换。 指令就是一个带有 @Directive() 装饰器的类。-->
<!--组件从技术角度上说就是一个指令，但是由于组件对 Angular 应用来说非常独特、非常重要，
因此 Angular 专门定义了 @Component() 装饰器，它使用一些面向模板的特性扩展了 @Directive() 装饰器。-->
<!--除组件外，还有两种指令：结构型指令和属性型指令。
Angular 本身定义了一系列这两种类型的指令，你也可以使用 @Directive() 装饰器来定义自己的指令。-->
<!--像组件一样，指令的元数据把它所装饰的指令类和一个 selector 关联起来，selector 用来把该指令插入到 HTML 中。
在模板中，指令通常作为属性出现在元素标签上，可能仅仅作为名字出现，也可能作为赋值目标或绑定目标出现。-->

<!--结构型指令-->
<!--结构型指令通过添加、移除或替换 DOM 元素来修改布局。 这个范例模板使用了两个内置的结构型指令来为要渲染的视图添加程序逻辑：-->
<!--<li *ngFor="let hero of heroes"></li>-->
<!--<app-hero-detail *ngIf="selectedHero"></app-hero-detail>-->
<!--*ngFor 是一个迭代器，它要求 Angular 为 heroes 列表中的每个英雄渲染出一个 <li>。-->
<!--*ngIf 是个条件语句，只有当选中的英雄存在时，它才会包含 HeroDetail 组件。-->

<!--属性型指令-->
<!--属性型指令会修改现有元素的外观或行为。 在模板中，它们看起来就像普通的 HTML 属性一样，因此得名“属性型指令”。-->
<!--ngModel 指令就是属性型指令的一个例子，它实现了双向数据绑定。
 ngModel 修改现有元素（一般是 <input>）的行为：设置其显示属性值，并响应 change 事件。-->
<!--<input [(ngModel)]="hero.name">-->
<!--Angular 还有很多预定义指令既不修改布局结构（比如 ngSwitch），也不修改 DOM 元素和组件的样子（比如 ngStyle 和 ngClass）。-->
